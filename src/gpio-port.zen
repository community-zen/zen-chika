const std = @import("std");
const ok = std.testing.ok;
const testing = std.testing;
const fs = std.fs;
const heap = std.heap;
const Allocator = heap.Allocator;
const mem = std.mem;
const math = std.math;
const os = std.os;

const Gpio = @import("gpio.zen").Gpio;

pub const GpioPin = enum(u5) {
    PIN_0 = 17,
    PIN_1 = 18,
    PIN_2 = 21,
    PIN_3 = 22,
    PIN_4 = 23,
    PIN_5 = 24,
    PIN_6 = 25,
    PIN_7 = 4,

    pub fn to_bcm_pin(comptime pin:GpioPin) comptime_int {
        return @enumToInt(pin);
    }
};

test "GpioPin" {
    const pin0 = GpioPin.PIN_0;
    const pin1 = GpioPin.PIN_1;
    const pin7 = GpioPin.PIN_7;

    comptime {
        std.testing.equal(17, pin0.to_bcm_pin() );
        std.testing.equal(18, pin1.to_bcm_pin() );
        std.testing.equal(4, pin7.to_bcm_pin() );
    }
}

pub const PinMode = enum(u3) {
    INPUT = 0,
    OUTPUT,
};

pub const GpioPort = struct {
    pin:GpioPin,
    gpio:Gpio,
    bcmPin:u5,
    const Self = @This();

    pub fn init(gpio:Gpio,pin:GpioPin) GpioPort {
        return Self{
            .pin = pin,
            .gpio = gpio,
            .bcmPin = @enumToInt(pin),
        };
    }
    pub fn pin_mode(self:Self,mode:PinMode) void {
        self.gpio.reg_fsel(self.bcmPin,@enumToInt(mode));
        return;
    }
    pub fn digital_write(self:Self,value:u1) void {
        switch (value) {
            0 => self.gpio.reg_clr(self.bcmPin),
            1 => self.gpio.reg_set(self.bcmPin),
            else => std.debug.panic("panic"),
        }
        return;
    }
    pub fn digital_Read(self:Self) u1 {
        return self.gpio.reg_lev(self.bcmPin);
    }
};

// test "GpioPort" {
//     const gpioPort = GpioPort.init();
// }

