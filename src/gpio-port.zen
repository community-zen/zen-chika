const std = @import("std");
const ok = std.testing.ok;
const testing = std.testing;
const fs = std.fs;
const heap = std.heap;
const Allocator = heap.Allocator;
const mem = std.mem;
const math = std.math;
const os = std.os;

const Gpio = @import("gpio.zen").Gpio;

pub const GpioPin = enum(u32) {
    PIN_0 = 17,
    PIN_1 = 18,
    PIN_2 = 21,
    PIN_3 = 22,
    PIN_4 = 23,
    PIN_5 = 24,
    PIN_6 = 25,
    PIN_7 = 4,

    pub fn to_phys_pin(comptime pin:GpioPin) u32 {
        return @enumToInt(pin);
    }
};

pub const PinMode = enum(u3) {
    INPUT = 0,
    OUTPUT,
};

pub const GpioPort = struct {
    pin:GpioPin,
    gpio:Gpio,
    physPin:u32,
    const Self = @This();

    pub fn init(gpio:Gpio,pin:GpioPin) GpioPort {
        // const physical = pin.to_phys_pin();
        return Self{
            .pin = pin,
            .gpio = gpio,
            .physPin = @enumToInt(pin),
        };
    }
    pub fn pin_mode(self:Self,mode:PinMode) void {
        self.gpio.reg_fsel(self.physPin,@enumToInt(mode));
        return;
    }
    pub fn digital_write(self:Self,value:u1) void {
        switch (value) {
            0 => self.gpio.reg_clr(self.physPin),
            1 => self.gpio.reg_set(self.physPin),
            else => @panic("panic"),
        }
        return;
    }
    pub fn digital_Read(self:Self,virPin:GpioPin) u1 {
        return self.gpio.reg_lev(self.physPin);
    }
};

// test "GpioPort" {
//     const gpioPort = GpioPort.init();
// }

