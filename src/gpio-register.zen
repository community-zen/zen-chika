const std = @import("std");
const builtin = @import("builtin");
const ok = std.testing.ok;
const testing = std.testing;
const fs = std.fs;
const heap = std.heap;
const Allocator = heap.Allocator;
const mem = std.mem;
const math = std.math;
const os = std.os;
const is_test = builtin.is_test;

pub const GpioRegister = packed struct {
    gpfsel0: u32 = 0,
    gpfsel1: u32 = 0,
    gpfsel2: u32 = 0,
    gpfsel3: u32 = 0,
    gpfsel4: u32 = 0,
    gpfsel5: u32 = 0,

    reserved0: [4]u8 = [_]u8{0}**4,
    gpset0: u32 = 0,
    gpset1: u32 = 0,

    reserved1: [4]u8 = [_]u8{0}**4,
    gpclr0: u32 = 0,
    gpclr1: u32 = 0,

    reserved2: [4]u8 = [_]u8{0}**4,
    gplev0: u32 = 0,
    gplev1: u32 = 0,

    reserved3: [4]u8 = [_]u8{0}**4,
    other:[100]u8 =  [_]u8{0}**100,

    var myPtr : []u8 = undefined;

    const OFFSET : u32 = 0x00200000;
    const BLOCK_SIZE = (4 * 1024);

    const Self = @This();

    pub fn get_ptr(baseAddress:usize) !GpioRegister {
        var MEM_PATH : [] const u8 = undefined;
        if( !is_test ) {
            MEM_PATH = "/dev/mem"[0..];
        } else {
            MEM_PATH = "src/test/mem"[0..];
        }

        const fd = try os.open(MEM_PATH, os.O_RDWR | os.O_SYNC | os.O_CLOEXEC,  0);
        errdefer os.close(fd);

        if ( fd == undefined )std.debug.warn("/dev/mem NG {} \n", fd);

        const bytes = try os.mmap(
            null,
            BLOCK_SIZE,
            os.PROT_READ | os.PROT_WRITE,
            os.MAP_SHARED,
            fd,
            baseAddress + OFFSET,
        );
        errdefer os.munmap(bytes);

        myPtr = bytes;

        return Self{};
    }
};

// test "GpioRegister" {
//     const valueMem = GpioRegister.get_ptr(0x3F000000);
//     if (valueMem) |value| {
//         GpioRegister.pin_mode(17,1);
//         GpioRegister.reg_set(17);
//         GpioRegister.reg_clr(17);
//     } else |err| {

//     }
// }

