const std = @import("std");
const ok = std.testing.ok;
const testing = std.testing;
const fs = std.fs;
const heap = std.heap;
const Allocator = heap.Allocator;
const mem = std.mem;
const math = std.math;
const os = std.os;

const BoardInfomation = @import("board-infomation.zen").BoardInfomation;
const PiModel = @import("board-infomation.zen").PiModel;
const GpioRegister = @import("gpio-register.zen").GpioRegister;
const Register = @import("common/register.zen");

test "GPIO" {

    const gpio = Gpio.init();

    const gpio2 = Gpio.init();

    std.testing.equal( gpio, gpio2 );

}


pub const Gpio = struct {
    boardInfo:BoardInfomation,
    gpioReg: *volatile GpioRegister,
    const Self = @This();

    var once : bool = false;
    var gpio : Gpio = undefined;

    pub fn init() Gpio {

        if( Self.once == true ) return Self.gpio;

        Self.gpio = Self {
            .boardInfo = BoardInfomation.init(),
            // .gpioReg = GpioRegister.get_ptr(0xFE000000) catch unreachable,
            .gpioReg = Register.getPtr( GpioRegister, 0x3F000000),
        };
        Self.once = true;

        return Self.gpio;

    }
    pub fn reg_fsel(self:Self,physPin:u32,mode:u3) void {
        var shift : u5 = @intCast(u5, (physPin % 10) * 3);
        var fselNum = (physPin / 10);

        if( mode == 0 or mode == 1 ){
            switch (fselNum) {
                0 => self.gpioReg.gpfsel0 = self.gpioReg.gpfsel0 & ~(@is(u32, 7)  << shift) | (@intCast(u32,mode) << shift),
                1 => self.gpioReg.gpfsel1 = self.gpioReg.gpfsel1 & ~(@is(u32, 7)  << shift) | (@intCast(u32,mode) << shift),
                2 => self.gpioReg.gpfsel2 = self.gpioReg.gpfsel2 & ~(@is(u32, 7)  << shift) | (@intCast(u32,mode) << shift),
                3 => self.gpioReg.gpfsel3 = self.gpioReg.gpfsel3 & ~(@is(u32, 7)  << shift) | (@intCast(u32,mode) << shift),
                4 => self.gpioReg.gpfsel4 = self.gpioReg.gpfsel4 & ~(@is(u32, 7)  << shift) | (@intCast(u32,mode) << shift),
                5 => self.gpioReg.gpfsel5 = self.gpioReg.gpfsel5 & ~(@is(u32, 7)  << shift) | (@intCast(u32,mode) << shift),
                else => @panic("panic"),
            }
        } else {
            @panic("panic");
        }
        return;
    }
    pub fn reg_set(self:Self,physPin:u32) void {
        var fselNum = (physPin / 32);
        switch (fselNum) {
            0 => {
                self.gpioReg.gpset0  = @is(u32, 1) << @intCast(u5,physPin);
            },
            1 => {
                self.gpioReg.gpset1  = @is(u32, 1) << @intCast(u5,physPin);
            },
            else => @panic("panic"),
        }
        return;
    }
    pub fn reg_clr(self:Self,physPin:u32) void {
        var fselNum = (physPin / 32);
        switch (fselNum) {
            0 => self.gpioReg.gpclr0  = @is(u32, 1) << @intCast(u5,physPin),
            1 => self.gpioReg.gpclr1  = @is(u32, 1) << @intCast(u5,physPin),
            else => @panic("panic"),
        }
        return;
    }
    pub fn reg_lev(self:Self,physPin:u32) u1 {
        var fselNum = (physPin / 32);

        // return switch (fselNum) {
        //     0 => self.gpioReg.gplev0,
        //     1 => self.gpioReg.gplev1,
        //     else => @panic("panic"),
        // };
        return @is(u1, 1);
    }
};

// test "Gpio" {
//     const gpio = Gpio.init() catch unreachable;
//     std.testing.equal(gpio.boardInfo.model, BoardInfomation.PiModel.PI_MODEL_4B);
//     std.testing.equal(gpio.boardInfo.maker, BoardInfomation.PiMaker.PI_MAKER_SONY_UK);
//     std.testing.equal(gpio.boardInfo.version, BoardInfomation.PiVersion.PI_VERSION_1_2);

//     Gpio.pin_mode(17,1) catch unreachable;
//     Gpio.reg_set(17) catch unreachable;
//     Gpio.reg_clr(17) catch unreachable;
// }

