///////////////////////////////////////////
// @brief  レジスタへの書き込みを管理
// @note
//   gpio-portから指示を受け、registerに書き込み指示を出す
///////////////////////////////////////////

const std = @import("std");

const BoardInfomation = @import("board-infomation.zen").BoardInfomation;
const PiModel = @import("board-infomation.zen").PiModel;
const GpioRegister = @import("gpio-register.zen").GpioRegister;
const Register = @import("common/register.zen");

pub const Gpio = struct {
    boardInfo:BoardInfomation,
    gpioReg: *volatile GpioRegister,
    const Self = @This();

    var once : bool = false;
    var gpio : Gpio = undefined;

    const registerBitWidth : u5 = 31;

    ///////////////////////////////////////////
    // @brief  初期化処理
    // @note
    //   Gpioコントローラを生成する
    //   gpioを使う際は必ず生成してください。なお、Gpioはシングルトンだよ。
    ///////////////////////////////////////////
    pub fn init() Gpio {

        // シングルトンとして実行する
        if( Self.once == true ) return Self.gpio;

        // 「bordInfo」で、ボード情報を元にペリフェラルベースアドレスを求めたのち、
        // 「gpioReg」より、gpioレジスタの先頭アドレスを取得する。
        const boardInfo = BoardInfomation.init();
        const gpioReg = Register.getPtr( GpioRegister, boardInfo.baseAddress );

        Self.gpio = Self {
            .boardInfo = boardInfo,
            .gpioReg = gpioReg,
        };
        Self.once = true;

        return Self.gpio;

    }

    ///////////////////////////////////////////
    // @brief  Pinモードを設定する
    // @note
    //   ユーザーが指定したピンを指定したモードに設定する
    //   ※INPUT,OUTPUTのみ対応
    ///////////////////////////////////////////
    pub fn reg_fsel( self:Self, bcmPin:u5, mode:u3 ) void {

        if( mode > 1 ){std.debug.panic("The mode value is abnormal. Expecting INPUT or OUTPUT.");}

        // GPIO毎に設定するべきFSELレジスタを求める
        const chooseFsel = (bcmPin / 10);
        var fsel = switch (chooseFsel) {
            0 => &self.gpioReg.gpfsel0,
            1 => &self.gpioReg.gpfsel1,
            2 => &self.gpioReg.gpfsel2,
            3 => &self.gpioReg.gpfsel3,
            4 => &self.gpioReg.gpfsel4,
            5 => &self.gpioReg.gpfsel5,
            else => std.debug.panic("The FSEL register is abnormal. Check the bcmPin number."),
        };

        const shift : u5 = @mod(bcmPin, 10) * 3;
        const threeBitMask = ~(@is(u32, 7)  << shift);
        const modeMask = @intCast(u32,mode) << shift;

        fsel.* = fsel.* & threeBitMask | modeMask;
    }

    ///////////////////////////////////////////
    // @brief  Setレジスタに対する書き込みを行う
    // @note
    //   対象のPinに対応するレジスタを判断する
    ///////////////////////////////////////////
    pub fn reg_set(self:Self,bcmPin:u5) void {
        var chooseSet = (bcmPin / registerBitWidth);

        var set = switch (chooseSet) {
            0 => &self.gpioReg.gpset0,
            1 => &self.gpioReg.gpset1,
            else => std.debug.panic("The SET register is abnormal. Check the bcmPin number."),
        };

        set.* = @is(u32, 1) << bcmPin;
    }

    ///////////////////////////////////////////
    // @brief  Clrレジスタに対する書き込みを行う
    // @note
    //   対象のPinに対応するレジスタを判断する
    ///////////////////////////////////////////
    pub fn reg_clr(self:Self,bcmPin:u5) void {
        var chooseClr = (bcmPin / registerBitWidth);

        var clr = switch (chooseClr) {
            0 => &self.gpioReg.gpclr0,
            1 => &self.gpioReg.gpclr1,
            else => std.debug.panic("The CLR register is abnormal. Check the bcmPin number."),
        };

        clr.* = @is(u32, 1) << bcmPin;
    }

    ///////////////////////////////////////////
    // @brief  Levレジスタから読み込みを行う
    // @note
    //   対象のPinに対応するレジスタを判断する
    ///////////////////////////////////////////
    pub fn reg_lev(self:Self, bcmPin:u5) u1 {
        var chooseLev = (bcmPin / registerBitWidth);

        // データが入っているレジスタを求める。
        var lev = switch (chooseLev) {
            0 => self.gpioReg.gplev0 ,
            1 => self.gpioReg.gplev1 ,
            else => std.debug.panic("The LEV register is abnormal. Check the bcmPin number."),
        };

        // レジスタからデータを取得する。
        return if(lev & (@is(u32, 1) << bcmPin) != 0)
            @is(u1, 1)
        else
            @is(u1, 0);

    }
};

// test "Gpio" {
//     const gpio = Gpio.init() catch unreachable;
//     std.testing.equal(gpio.boardInfo.model, BoardInfomation.PiModel.PI_MODEL_4B);
//     std.testing.equal(gpio.boardInfo.maker, BoardInfomation.PiMaker.PI_MAKER_SONY_UK);
//     std.testing.equal(gpio.boardInfo.version, BoardInfomation.PiVersion.PI_VERSION_1_2);

//     Gpio.pin_mode(17,1) catch unreachable;
//     Gpio.reg_set(17) catch unreachable;
//     Gpio.reg_clr(17) catch unreachable;
// }

